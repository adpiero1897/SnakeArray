import java.util.Random;

public class SnakeArrayClass {

    public static void main(String[] args) {
        Random rand = new Random();
       /* int[][] snakeArr = new int[rand.nextInt(20)][];//Сгенерируем случайную разменрность (20-) входного массива
        for (int i = 0; i < snakeArr.length; i++) {
            snakeArr[i] = new int[rand.nextInt(20)];//Сгенерируем случайную ступенчатую структуру этого массива
            if(snakeArr[i].length < 2){ //Чтобы недопустить нулевых столбцов без элементов во входном массиве
                i--;
            }
        }*/
        //закомментированный код задаёт ступенчатый массив, раскомментируй её и закомменть строку ниже, если хочешь хардкор
        int[][] snakeArr = new int[10][6]; //Эта строка задаёт прямоугольный массив
        snakeArr=snakeArrayInitial(snakeArr);

        //Найдем максимальный j, чтобы организовать вывод в консоль получившегося ступенчатого массива
        int MaxLength=snakeArr[0].length;
        for(int i = 1; i < snakeArr.length; i++){
            MaxLength = Math.max(MaxLength,snakeArr[i].length);
        }

        for (int j = 0; j < MaxLength; j++) {  //Вывод элементов массива в консоль после инициализации
            for (int i = 0; i < snakeArr.length; i++) {
                if(j<snakeArr[i].length) {
                    System.out.print(snakeArr[i][j] + "  ");
                    //залепа для красивого вывода массива из менее, чем 1000 элементов
                    if(snakeArr[i][j] <100 ){
                        System.out.print(" ");
                    }
                    if(snakeArr[i][j] <10 ){
                        System.out.print(" ");
                    }
                }else{
                    System.out.print("     ");
                }
            }
            System.out.println();
        }
    }

    public static int[][] snakeArrayInitial(int[][] arr){
        int counter = 1; //счетчик чисел заполняется змейка в порядке инкрементирующегося счетчика
        int i=0,j=0; //индексы элементов массива инициализировали

        while(true) {   //змейка циклично поворачивает на 360°
            for (; i < arr.length && arr[i][j] == 0; i++) {  //Цикл направления "змейки" для движ. вправо →
                arr[i][j] = counter++;//Сгенерируем случайную ступенчатую структуру этого массива
            }
            i--;
            j++; //переходим на движение вниз
            if (arr[i][j] != 0) {    //Змейка наткнулась на препятсвие - заканчиваем заполнение массива (и цикл while)
                return arr;
            }
            for (; j < arr[i].length  && arr[i][j] == 0; j++) {  //Цикл направления "змейки" для движ. вниз ↓
                arr[i][j] = counter++;
            }

            i--; //переходим на движение влево
            for(j = arr[i].length - 1;arr[i][j] != 0;j--){
                if (j==0) {    //Змейка наткнулась на препятсвие - заканчиваем заполнение массива (и цикл while)
                    return arr;
                }
            } //из-за ступенчатости приходится искать нижний 0 (его j-индекс) в столбце
            for (; i >= 0 ; i--) {  //Цикл направления "змейки" для движ. влево
                int jbuff;  //буфер для значения индекса j
                for(jbuff = arr[i].length - 1; jbuff>0 && arr[i][jbuff] != 0;jbuff--){

                }
                    if (jbuff==0) {    //Змейка дошла до верхнего предела, который ограничивает её движение влево ←
                        break;
                    }

                j = jbuff;//из-за ступенчатости приходится искать нижний 0 (его j-индекс в столбце)
                arr[i][j] = counter++;
            }
            i++; //только вот вернем i на тот столбец, который ещё не был преградой
            j--; //переходим на движение вверх
            if (arr[i][j] != 0) {    //Змейка наткнулась на препятсвие - заканчиваем заполнение массива (и цикл while)
                return arr;
            }
            for (;j > 0 && arr[i][j] == 0; j--) {  //Цикл направления "змейки" для движ. вверх ↑
                arr[i][j] = counter++;
            }
            j++;
            i++;  //Полный цикл поворота на 360° прошел. Переходим на движение "змейки" опять вправо →
            if (arr[i][j] != 0) {    //Змейка наткнулась на препятсвие - заканчиваем заполнение массива (и цикл while)
                return arr;
            }
        }

    }
}
